// Code generated by cmd/cgo; DO NOT EDIT.

//line /go/pkg/mod/github.com/mattn/go-sqlite3@v1.9.0/callback.go:1:1
// Copyright (C) 2014 Yasuhiro Matsumoto <mattn.jp@gmail.com>.
//
// Use of this source code is governed by an MIT-style
// license that can be found in the LICENSE file.

package sqlite3; import _cgo_unsafe "unsafe"

// You can't export a Go function to C and have definitions in the C
// preamble in the same file, so we have to have callbackTrampoline in
// its own file. Because we need a separate file anyway, the support
// code for SQLite custom functions is in here.

/*
#ifndef USE_LIBSQLITE3
#include <sqlite3-binding.h>
#else
#include <sqlite3.h>
#endif
#include <stdlib.h>

void _sqlite3_result_text(sqlite3_context* ctx, const char* s);
void _sqlite3_result_blob(sqlite3_context* ctx, const void* b, int l);
*/
import _ "unsafe"

import (
	"errors"
	"fmt"
	"math"
	"reflect"
	"sync"
	"unsafe"
)

//export callbackTrampoline
func callbackTrampoline(ctx * /*line :36:30*/_Ctype_struct_sqlite3_context /*line :36:47*/, argc int, argv ** /*line :36:66*/_Ctype_struct_sqlite3_value /*line :36:81*/) {
	args := (*[(math.MaxInt32 - 1) / unsafe.Sizeof((* /*line :37:51*/_Ctype_struct_sqlite3_value /*line :37:66*/)(nil))]* /*line :37:75*/_Ctype_struct_sqlite3_value /*line :37:90*/)(unsafe.Pointer(argv))[:argc:argc]
	fi := lookupHandle(uintptr(func() _cgo_unsafe.Pointer{ _cgo0 := /*line :38:49*/ctx; _cgoCheckPointer(_cgo0, nil); return _Cfunc_sqlite3_user_data(_cgo0); }())).(*functionInfo)
	fi.Call(ctx, args)
}

//export stepTrampoline
func stepTrampoline(ctx * /*line :43:26*/_Ctype_struct_sqlite3_context /*line :43:43*/, argc  /*line :43:50*/_Ctype_int /*line :43:55*/, argv ** /*line :43:64*/_Ctype_struct_sqlite3_value /*line :43:79*/) {
	args := (*[(math.MaxInt32 - 1) / unsafe.Sizeof((* /*line :44:51*/_Ctype_struct_sqlite3_value /*line :44:66*/)(nil))]* /*line :44:75*/_Ctype_struct_sqlite3_value /*line :44:90*/)(unsafe.Pointer(argv))[:int(argc):int(argc)]
	ai := lookupHandle(uintptr(func() _cgo_unsafe.Pointer{ _cgo0 := /*line :45:49*/ctx; _cgoCheckPointer(_cgo0, nil); return _Cfunc_sqlite3_user_data(_cgo0); }())).(*aggInfo)
	ai.Step(ctx, args)
}

//export doneTrampoline
func doneTrampoline(ctx * /*line :50:26*/_Ctype_struct_sqlite3_context /*line :50:43*/) {
	handle := uintptr(func() _cgo_unsafe.Pointer{ _cgo0 := /*line :51:40*/ctx; _cgoCheckPointer(_cgo0, nil); return _Cfunc_sqlite3_user_data(_cgo0); }())
	ai := lookupHandle(handle).(*aggInfo)
	ai.Done(ctx)
}

//export compareTrampoline
func compareTrampoline(handlePtr uintptr, la  /*line :57:46*/_Ctype_int /*line :57:51*/, a * /*line :57:56*/_Ctype_char /*line :57:62*/, lb  /*line :57:67*/_Ctype_int /*line :57:72*/, b * /*line :57:77*/_Ctype_char /*line :57:83*/)  /*line :57:85*/_Ctype_int /*line :57:90*/ {
	cmp := lookupHandle(handlePtr).(func(string, string) int)
	return  /*line :59:9*/_Ctype_int /*line :59:14*/(cmp(( /*line :59:19*/_Cfunc_GoStringN /*line :59:29*/)(a, la), ( /*line :59:39*/_Cfunc_GoStringN /*line :59:49*/)(b, lb)))
}

//export commitHookTrampoline
func commitHookTrampoline(handle uintptr) int {
	callback := lookupHandle(handle).(func() int)
	return callback()
}

//export rollbackHookTrampoline
func rollbackHookTrampoline(handle uintptr) {
	callback := lookupHandle(handle).(func())
	callback()
}

//export updateHookTrampoline
func updateHookTrampoline(handle uintptr, op int, db * /*line :75:55*/_Ctype_char /*line :75:61*/, table * /*line :75:70*/_Ctype_char /*line :75:76*/, rowid int64) {
	callback := lookupHandle(handle).(func(int, string, string, int64))
	callback(op, ( /*line :77:15*/_Cfunc_GoString /*line :77:24*/)(db), ( /*line :77:31*/_Cfunc_GoString /*line :77:40*/)(table), rowid)
}

// Use handles to avoid passing Go pointers to C.

type handleVal struct {
	db  *SQLiteConn
	val interface{}
}

var handleLock sync.Mutex
var handleVals = make(map[uintptr]handleVal)
var handleIndex uintptr = 100

func newHandle(db *SQLiteConn, v interface{}) uintptr {
	handleLock.Lock()
	defer handleLock.Unlock()
	i := handleIndex
	handleIndex++
	handleVals[i] = handleVal{db, v}
	return i
}

func lookupHandle(handle uintptr) interface{} {
	handleLock.Lock()
	defer handleLock.Unlock()
	r, ok := handleVals[handle]
	if !ok {
		if handle >= 100 && handle < handleIndex {
			panic("deleted handle")
		} else {
			panic("invalid handle")
		}
	}
	return r.val
}

func deleteHandles(db *SQLiteConn) {
	handleLock.Lock()
	defer handleLock.Unlock()
	for handle, val := range handleVals {
		if val.db == db {
			delete(handleVals, handle)
		}
	}
}

// This is only here so that tests can refer to it.
type callbackArgRaw  /*line :125:21*/_Ctype_struct_sqlite3_value /*line :125:36*/

type callbackArgConverter func(* /*line :127:33*/_Ctype_struct_sqlite3_value /*line :127:48*/) (reflect.Value, error)

type callbackArgCast struct {
	f   callbackArgConverter
	typ reflect.Type
}

func (c callbackArgCast) Run(v * /*line :134:33*/_Ctype_struct_sqlite3_value /*line :134:48*/) (reflect.Value, error) {
	val, err := c.f(v)
	if err != nil {
		return reflect.Value{}, err
	}
	if !val.Type().ConvertibleTo(c.typ) {
		return reflect.Value{}, fmt.Errorf("cannot convert %s to %s", val.Type(), c.typ)
	}
	return val.Convert(c.typ), nil
}

func callbackArgInt64(v * /*line :145:26*/_Ctype_struct_sqlite3_value /*line :145:41*/) (reflect.Value, error) {
	if func() _Ctype_int{ _cgo0 := /*line :146:26*/v; _cgoCheckPointer(_cgo0, nil); return _Cfunc_sqlite3_value_type(_cgo0); }() != ( /*line :146:32*/_Ciconst_SQLITE_INTEGER /*line :146:47*/) {
		return reflect.Value{}, fmt.Errorf("argument must be an INTEGER")
	}
	return reflect.ValueOf(int64(func() _Ctype_sqlite3_int64{ _cgo0 := /*line :149:53*/v; _cgoCheckPointer(_cgo0, nil); return _Cfunc_sqlite3_value_int64(_cgo0); }())), nil
}

func callbackArgBool(v * /*line :152:25*/_Ctype_struct_sqlite3_value /*line :152:40*/) (reflect.Value, error) {
	if func() _Ctype_int{ _cgo0 := /*line :153:26*/v; _cgoCheckPointer(_cgo0, nil); return _Cfunc_sqlite3_value_type(_cgo0); }() != ( /*line :153:32*/_Ciconst_SQLITE_INTEGER /*line :153:47*/) {
		return reflect.Value{}, fmt.Errorf("argument must be an INTEGER")
	}
	i := int64(func() _Ctype_sqlite3_int64{ _cgo0 := /*line :156:35*/v; _cgoCheckPointer(_cgo0, nil); return _Cfunc_sqlite3_value_int64(_cgo0); }())
	val := false
	if i != 0 {
		val = true
	}
	return reflect.ValueOf(val), nil
}

func callbackArgFloat64(v * /*line :164:28*/_Ctype_struct_sqlite3_value /*line :164:43*/) (reflect.Value, error) {
	if func() _Ctype_int{ _cgo0 := /*line :165:26*/v; _cgoCheckPointer(_cgo0, nil); return _Cfunc_sqlite3_value_type(_cgo0); }() != ( /*line :165:32*/_Ciconst_SQLITE_FLOAT /*line :165:45*/) {
		return reflect.Value{}, fmt.Errorf("argument must be a FLOAT")
	}
	return reflect.ValueOf(float64(func() _Ctype_double{ _cgo0 := /*line :168:56*/v; _cgoCheckPointer(_cgo0, nil); return _Cfunc_sqlite3_value_double(_cgo0); }())), nil
}

func callbackArgBytes(v * /*line :171:26*/_Ctype_struct_sqlite3_value /*line :171:41*/) (reflect.Value, error) {
	switch func() _Ctype_int{ _cgo0 := /*line :172:30*/v; _cgoCheckPointer(_cgo0, nil); return _Cfunc_sqlite3_value_type(_cgo0); }() {
	case ( /*line :173:7*/_Ciconst_SQLITE_BLOB /*line :173:19*/):
		l := func() _Ctype_int{ _cgo0 := /*line :174:30*/v; _cgoCheckPointer(_cgo0, nil); return _Cfunc_sqlite3_value_bytes(_cgo0); }()
		p := func() _cgo_unsafe.Pointer{ _cgo0 := /*line :175:29*/v; _cgoCheckPointer(_cgo0, nil); return _Cfunc_sqlite3_value_blob(_cgo0); }()
		return reflect.ValueOf(func() []byte{ _cgo0 := /*line :176:36*/p; var _cgo1 _Ctype_int = /*line :176:39*/l; _cgoCheckPointer(_cgo0, nil); return _Cfunc_GoBytes(_cgo0, _cgo1); }()), nil
	case ( /*line :177:7*/_Ciconst_SQLITE_TEXT /*line :177:19*/):
		l := func() _Ctype_int{ _cgo0 := /*line :178:30*/v; _cgoCheckPointer(_cgo0, nil); return _Cfunc_sqlite3_value_bytes(_cgo0); }()
		c := unsafe.Pointer(func() *_Ctype_uchar{ _cgo0 := /*line :179:44*/v; _cgoCheckPointer(_cgo0, nil); return _Cfunc_sqlite3_value_text(_cgo0); }())
		return reflect.ValueOf(func() []byte{ _cgo0 := /*line :180:36*/c; var _cgo1 _Ctype_int = /*line :180:39*/l; _cgoCheckPointer(_cgo0, nil); return _Cfunc_GoBytes(_cgo0, _cgo1); }()), nil
	default:
		return reflect.Value{}, fmt.Errorf("argument must be BLOB or TEXT")
	}
}

func callbackArgString(v * /*line :186:27*/_Ctype_struct_sqlite3_value /*line :186:42*/) (reflect.Value, error) {
	switch func() _Ctype_int{ _cgo0 := /*line :187:30*/v; _cgoCheckPointer(_cgo0, nil); return _Cfunc_sqlite3_value_type(_cgo0); }() {
	case ( /*line :188:7*/_Ciconst_SQLITE_BLOB /*line :188:19*/):
		l := func() _Ctype_int{ _cgo0 := /*line :189:30*/v; _cgoCheckPointer(_cgo0, nil); return _Cfunc_sqlite3_value_bytes(_cgo0); }()
		p := (* /*line :190:10*/_Ctype_char /*line :190:16*/)(func() _cgo_unsafe.Pointer{ _cgo0 := /*line :190:39*/v; _cgoCheckPointer(_cgo0, nil); return _Cfunc_sqlite3_value_blob(_cgo0); }())
		return reflect.ValueOf(( /*line :191:26*/_Cfunc_GoStringN /*line :191:36*/)(p, l)), nil
	case ( /*line :192:7*/_Ciconst_SQLITE_TEXT /*line :192:19*/):
		c := (* /*line :193:10*/_Ctype_char /*line :193:16*/)(unsafe.Pointer(func() *_Ctype_uchar{ _cgo0 := /*line :193:54*/v; _cgoCheckPointer(_cgo0, nil); return _Cfunc_sqlite3_value_text(_cgo0); }()))
		return reflect.ValueOf(( /*line :194:26*/_Cfunc_GoString /*line :194:35*/)(c)), nil
	default:
		return reflect.Value{}, fmt.Errorf("argument must be BLOB or TEXT")
	}
}

func callbackArgGeneric(v * /*line :200:28*/_Ctype_struct_sqlite3_value /*line :200:43*/) (reflect.Value, error) {
	switch func() _Ctype_int{ _cgo0 := /*line :201:30*/v; _cgoCheckPointer(_cgo0, nil); return _Cfunc_sqlite3_value_type(_cgo0); }() {
	case ( /*line :202:7*/_Ciconst_SQLITE_INTEGER /*line :202:22*/):
		return callbackArgInt64(v)
	case ( /*line :204:7*/_Ciconst_SQLITE_FLOAT /*line :204:20*/):
		return callbackArgFloat64(v)
	case ( /*line :206:7*/_Ciconst_SQLITE_TEXT /*line :206:19*/):
		return callbackArgString(v)
	case ( /*line :208:7*/_Ciconst_SQLITE_BLOB /*line :208:19*/):
		return callbackArgBytes(v)
	case ( /*line :210:7*/_Ciconst_SQLITE_NULL /*line :210:19*/):
		// Interpret NULL as a nil byte slice.
		var ret []byte
		return reflect.ValueOf(ret), nil
	default:
		panic("unreachable")
	}
}

func callbackArg(typ reflect.Type) (callbackArgConverter, error) {
	switch typ.Kind() {
	case reflect.Interface:
		if typ.NumMethod() != 0 {
			return nil, errors.New("the only supported interface type is interface{}")
		}
		return callbackArgGeneric, nil
	case reflect.Slice:
		if typ.Elem().Kind() != reflect.Uint8 {
			return nil, errors.New("the only supported slice type is []byte")
		}
		return callbackArgBytes, nil
	case reflect.String:
		return callbackArgString, nil
	case reflect.Bool:
		return callbackArgBool, nil
	case reflect.Int64:
		return callbackArgInt64, nil
	case reflect.Int8, reflect.Int16, reflect.Int32, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Int, reflect.Uint:
		c := callbackArgCast{callbackArgInt64, typ}
		return c.Run, nil
	case reflect.Float64:
		return callbackArgFloat64, nil
	case reflect.Float32:
		c := callbackArgCast{callbackArgFloat64, typ}
		return c.Run, nil
	default:
		return nil, fmt.Errorf("don't know how to convert to %s", typ)
	}
}

func callbackConvertArgs(argv []* /*line :250:34*/_Ctype_struct_sqlite3_value /*line :250:49*/, converters []callbackArgConverter, variadic callbackArgConverter) ([]reflect.Value, error) {
	var args []reflect.Value

	if len(argv) < len(converters) {
		return nil, fmt.Errorf("function requires at least %d arguments", len(converters))
	}

	for i, arg := range argv[:len(converters)] {
		v, err := converters[i](arg)
		if err != nil {
			return nil, err
		}
		args = append(args, v)
	}

	if variadic != nil {
		for _, arg := range argv[len(converters):] {
			v, err := variadic(arg)
			if err != nil {
				return nil, err
			}
			args = append(args, v)
		}
	}
	return args, nil
}

type callbackRetConverter func(* /*line :277:33*/_Ctype_struct_sqlite3_context /*line :277:50*/, reflect.Value) error

func callbackRetInteger(ctx * /*line :279:30*/_Ctype_struct_sqlite3_context /*line :279:47*/, v reflect.Value) error {
	switch v.Type().Kind() {
	case reflect.Int64:
	case reflect.Int8, reflect.Int16, reflect.Int32, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Int, reflect.Uint:
		v = v.Convert(reflect.TypeOf(int64(0)))
	case reflect.Bool:
		b := v.Interface().(bool)
		if b {
			v = reflect.ValueOf(int64(1))
		} else {
			v = reflect.ValueOf(int64(0))
		}
	default:
		return fmt.Errorf("cannot convert %s to INTEGER", v.Type())
	}

	func() { _cgo0 := /*line :295:25*/ctx; var _cgo1 _Ctype_sqlite3_int64 = _Ctype_sqlite3_int64(v.Interface().(int64)); _cgoCheckPointer(_cgo0, nil); _Cfunc_sqlite3_result_int64(_cgo0, _cgo1); }()
	return nil
}

func callbackRetFloat(ctx * /*line :299:28*/_Ctype_struct_sqlite3_context /*line :299:45*/, v reflect.Value) error {
	switch v.Type().Kind() {
	case reflect.Float64:
	case reflect.Float32:
		v = v.Convert(reflect.TypeOf(float64(0)))
	default:
		return fmt.Errorf("cannot convert %s to FLOAT", v.Type())
	}

	func() { _cgo0 := /*line :308:26*/ctx; var _cgo1 _Ctype_double = _Ctype_double(v.Interface().(float64)); _cgoCheckPointer(_cgo0, nil); _Cfunc_sqlite3_result_double(_cgo0, _cgo1); }()
	return nil
}

func callbackRetBlob(ctx * /*line :312:27*/_Ctype_struct_sqlite3_context /*line :312:44*/, v reflect.Value) error {
	if v.Type().Kind() != reflect.Slice || v.Type().Elem().Kind() != reflect.Uint8 {
		return fmt.Errorf("cannot convert %s to BLOB", v.Type())
	}
	i := v.Interface()
	if i == nil || len(i.([]byte)) == 0 {
		func() { _cgo0 := /*line :318:25*/ctx; _cgoCheckPointer(_cgo0, nil); _Cfunc_sqlite3_result_null(_cgo0); }()
	} else {
		bs := i.([]byte)
		func() { _cgo0 := /*line :321:26*/ctx; _cgoIndex1 := &/*line :321:47*/bs; _cgo1 := /*line :321:31*/unsafe.Pointer(&(*_cgoIndex1)[0]); var _cgo2 _Ctype_int = _Ctype_int(len(bs)); _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgo1, *_cgoIndex1); _Cfunc__sqlite3_result_blob(_cgo0, _cgo1, _cgo2); }()
	}
	return nil
}

func callbackRetText(ctx * /*line :326:27*/_Ctype_struct_sqlite3_context /*line :326:44*/, v reflect.Value) error {
	if v.Type().Kind() != reflect.String {
		return fmt.Errorf("cannot convert %s to TEXT", v.Type())
	}
	func() { _cgo0 := /*line :330:25*/ctx; var _cgo1 *_Ctype_char = _Cfunc_CString(v.Interface().(string)); _cgoCheckPointer(_cgo0, nil); _Cfunc__sqlite3_result_text(_cgo0, _cgo1); }()
	return nil
}

func callbackRetNil(ctx * /*line :334:26*/_Ctype_struct_sqlite3_context /*line :334:43*/, v reflect.Value) error {
	return nil
}

func callbackRet(typ reflect.Type) (callbackRetConverter, error) {
	switch typ.Kind() {
	case reflect.Interface:
		errorInterface := reflect.TypeOf((*error)(nil)).Elem()
		if typ.Implements(errorInterface) {
			return callbackRetNil, nil
		}
		fallthrough
	case reflect.Slice:
		if typ.Elem().Kind() != reflect.Uint8 {
			return nil, errors.New("the only supported slice type is []byte")
		}
		return callbackRetBlob, nil
	case reflect.String:
		return callbackRetText, nil
	case reflect.Bool, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Int, reflect.Uint:
		return callbackRetInteger, nil
	case reflect.Float32, reflect.Float64:
		return callbackRetFloat, nil
	default:
		return nil, fmt.Errorf("don't know how to convert to %s", typ)
	}
}

func callbackError(ctx * /*line :362:25*/_Ctype_struct_sqlite3_context /*line :362:42*/, err error) {
	cstr := ( /*line :363:10*/_Cfunc_CString /*line :363:18*/)(err.Error())
	defer func() func() { _cgo0 := /*line :364:15*/unsafe.Pointer(cstr); return func() { _cgoCheckPointer(_cgo0, nil); _Cfunc_free(_cgo0); }}()()
	func() { _cgo0 := /*line :365:25*/ctx; var _cgo1 *_Ctype_char = /*line :365:30*/cstr; var _cgo2 _Ctype_int = /*line :365:36*/-1; _cgoCheckPointer(_cgo0, nil); _Cfunc_sqlite3_result_error(_cgo0, _cgo1, _cgo2); }()
}

// Test support code. Tests are not allowed to import "C", so we can't
// declare any functions that use C.sqlite3_value.
func callbackSyntheticForTests(v reflect.Value, err error) callbackArgConverter {
	return func(* /*line :371:15*/_Ctype_struct_sqlite3_value /*line :371:30*/) (reflect.Value, error) {
		return v, err
	}
}
